/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../../common";

export interface MerkleV2Interface extends Interface {
  getFunction(
    nameOrSignature:
      | "calculateRootFromPowerOfTwo"
      | "getEmptyTreeHashAtIndex"
      | "getHashOfWordAtIndex"
      | "getMerkleRootFromBytes"
      | "getRootAfterReplacementInDrive"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "calculateRootFromPowerOfTwo",
    values: [BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getEmptyTreeHashAtIndex",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getHashOfWordAtIndex",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getMerkleRootFromBytes",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getRootAfterReplacementInDrive",
    values: [BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike[]]
  ): string;

  decodeFunctionResult(
    functionFragment: "calculateRootFromPowerOfTwo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getEmptyTreeHashAtIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getHashOfWordAtIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMerkleRootFromBytes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRootAfterReplacementInDrive",
    data: BytesLike
  ): Result;
}

export interface MerkleV2 extends BaseContract {
  connect(runner?: ContractRunner | null): MerkleV2;
  waitForDeployment(): Promise<this>;

  interface: MerkleV2Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  /**
   * Calculate the root of Merkle tree from an array of power of 2 elements
   * @param hashes The array containing power of 2 elements
   */
  calculateRootFromPowerOfTwo: TypedContractMethod<
    [hashes: BytesLike[]],
    [string],
    "view"
  >;

  /**
   * first index is keccak(0), second index is keccak(keccak(0), keccak(0))
   * Gets precomputed hash of zero in empty tree hashes
   * @param _index of hash wanted
   */
  getEmptyTreeHashAtIndex: TypedContractMethod<
    [_index: BigNumberish],
    [string],
    "view"
  >;

  /**
   * if word is incomplete (< 8 bytes) it gets padded with zeroes
   * Get the hash of a word in an array of bytes
   * @param _data array of bytes
   * @param _wordIndex index of word inside the bytes to get the hash of
   */
  getHashOfWordAtIndex: TypedContractMethod<
    [_data: BytesLike, _wordIndex: BigNumberish],
    [string],
    "view"
  >;

  /**
   * _data is padded with zeroes until is multiple of 8root is completed with zero tree until log2size is completehashes are taken word by word (8 bytes by 8 bytes)
   * get merkle root of generic array of bytes
   * @param _data array of bytes to be merklelized
   * @param _log2Size log2 of total size of the drive
   */
  getMerkleRootFromBytes: TypedContractMethod<
    [_data: BytesLike, _log2Size: BigNumberish],
    [string],
    "view"
  >;

  /**
   * Gets merkle root hash of drive with a replacement
   * @param _logSizeOfFullDrive log2 of size the full drive, which can be the entire machine
   * @param _logSizeOfReplacement log2 of size the replacement
   * @param _position position of _drive
   * @param _replacement hash of the replacement
   * @param siblings of replacement that merkle root can be calculated
   */
  getRootAfterReplacementInDrive: TypedContractMethod<
    [
      _position: BigNumberish,
      _logSizeOfReplacement: BigNumberish,
      _logSizeOfFullDrive: BigNumberish,
      _replacement: BytesLike,
      siblings: BytesLike[]
    ],
    [string],
    "view"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "calculateRootFromPowerOfTwo"
  ): TypedContractMethod<[hashes: BytesLike[]], [string], "view">;
  getFunction(
    nameOrSignature: "getEmptyTreeHashAtIndex"
  ): TypedContractMethod<[_index: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "getHashOfWordAtIndex"
  ): TypedContractMethod<
    [_data: BytesLike, _wordIndex: BigNumberish],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getMerkleRootFromBytes"
  ): TypedContractMethod<
    [_data: BytesLike, _log2Size: BigNumberish],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getRootAfterReplacementInDrive"
  ): TypedContractMethod<
    [
      _position: BigNumberish,
      _logSizeOfReplacement: BigNumberish,
      _logSizeOfFullDrive: BigNumberish,
      _replacement: BytesLike,
      siblings: BytesLike[]
    ],
    [string],
    "view"
  >;

  filters: {};
}
